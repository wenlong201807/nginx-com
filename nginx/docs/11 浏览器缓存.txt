看图

Nginx系列-资源缓存配置 https://juejin.cn/post/7016295905762476063

location / {
  root html;
  index  index.html index.htm;
  add_header Cache-Control private;

  #设置缓存时间
  expires 1d; # 响应头返回了 Cache-Control:max-age=86400 时间
  # expires 1d; 当下次请求在1天时间范围内，则直接采用浏览器的缓存，若超出时间，则需向服务器校验，若无资源无更新，服务器会返回304状态码，此时会刷新缓存的新鲜度，并将资源给客户端。
  # 新鲜度 age=0 第一次请求记录下来，达到max-age 时，再重新清零计算，未达到这个事件，则更新age计时。

  
  add_header Cache-Control no-cache; # 禁用强缓存
  # no-cache 多次刷新浏览器后，会发现文件响应码都是304了，走了协商缓存，也就是每次都向服务器发起了文件校验。
  add_header Cache-Control no-store; # 禁用缓存
  # no-store 多次刷新浏览器后，会发现资源文件的请求都走200了，没有从缓存获取数据了。
}

private 只能针对个人用户，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中，当然默认配置项是 private。
public，则表示响应可以被任何中间人缓存。

----没太理解的----
1 Etag 是一种作为web资源关联的标记，由响应头传送给客户端，下次请求会通过请求头 If-None-Match 带上，若服务器资源未发生变化，则返回 304 状态码。它主要是为了解决 Last-Modified 上的一些不足，比如
  某些文件修改是在秒级以下速度进行修改，但If-Modified-Since 能检查到的粒度是s级的。

2 采用弱 Etag，此时它是基于 MTime 来生成，只能精确到s，所以1s秒内生成的 Etag 是一样的。可以避免强 Etag 造成的频繁缓存刷新。弱 Etag 以 W/ 开头。
  某些文件会周期性变更，但其内容是不变化的，此时我们不希望它被认为被修改了等。
  某些服务器不能精准获取文件的最后修改时间。

3 from memory cache
  不请求网络资源，资源存储在内存中，一般存储的有字体、图片、脚本

4 from disk cache
  不请求网络资源，资源存储在磁盘中，一般存储非脚本资源，如css。

------------------------------------------------

如何使用浏览器缓存和Nginx，提升首屏访问速度
参考资料 https://juejin.cn/post/7050004962155167781

一、缓存操作的目标
  提升首屏访问速度

二、背景
  重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力
  因此需要自定义扩展缓存

三、缓存的关键
  主要包括request method和目标URI（一般只有GET请求才会被缓存）

四、普遍的缓存案例
  1 一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。
  2 永久重定向: 响应状态码：301。
  3 错误响应: 响应状态码：404 的一个页面。
  4 不完全的响应: 响应状态码 206，只返回局部的信息。
  5 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应。

五、详解缓存机制
  1 Cache-control 头
    定义: 
      HTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。
    内容:
      1 Cache-Control: no-store 没有缓存
        缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
      2 Cache-Control: no-cache 缓存但重新验证
        此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。
      3 Cache-Control: public 公共缓存
        "public" 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。
      4 Cache-Control: private 私有缓存
        "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
      5 Cache-Control: max-age=31536000 过期策略
        过期机制中，最重要的指令是 "max-age=<seconds>"，表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。
      6 Cache-Control: must-revalidate 
        "must-revalidate" 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。
        详情看下文关于缓存校验的内容。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching#Cache_validation

六、Expires
  1 Expires 响应头包含日期/时间， 即在此时候之后，响应过期。
  2 无效的日期，比如 0, 代表着过去的日期，即该资源已经过期。
  3 如果在Cache-Control响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略。

七、缓存验证
  1 用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有"Cache-control: must-revalidate”的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced->Cache为强制验证缓存也能达到相同的效果。
  2 当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。

八、ETags
  1 作为缓存的一种强校验器，ETag 响应头是一个对用户代理(User Agent, 下面简称UA)不透明（译者注：UA 无需理解，只需要按规定使用即可）的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。
  
  2 Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。
  
  3 当向服务端发起缓存校验的请求时，服务端会返回 200 ok表示返回正常的结果或者 304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。


---------------------------------------------------------------
浏览器缓存缓存策略（看完就懂）
https://juejin.cn/post/6888875643266662414

一、浏览器缓存目的
  节省带宽、提高加载和渲染速度、减少网络阻塞，以及提高用户体验

二、浏览器的缓存过程
  1 开始加载，域名解析，DNS缓存
  2 本地缓存（memory缓存）
  3 Http缓存（强缓存和协商缓存）
  4 服务端缓存（cdn缓存）

三、DNS缓存
  1 通常我们输入一个网址，它包含了域名和端口可以指定唯一的IP地址，然后建立连接进行通信，而域名查找IP地址的过程就是dns解析。
    示例代码 www.dnscache.com (域名) - DNS解析 -> 11.222.33.444 (IP地址)
  2 这个过程会对网络请求带来一定的损耗，所以浏览器在第一次获取到IP地址后，会将其缓存起来。下次相同域名再次发起请求时，浏览器会先查找本地缓存，如果缓存有效，则会直接返回该IP地址，否则会继续开始寻址之旅。
    2.1 首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。
    2.2 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。
    2.3 如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。
    2.4 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。

四、memory cache（本地缓存）
  1 memory cache 是浏览器为了加快读取缓存速度而进行的自身的优化行为，不受开发者控制，也不受 HTTP 协议头的约束。
  2 当资源被存入内存后，下次同样的请求将不再通过网络，而是直接访问内存
  3 当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不再出现from memory cache的情况。
  4 什么时候资源会被放入memory缓存呢？
    4.1 几乎所有的网络请求资源都会根据相关的策略被浏览器自动加入到 memory cache 中。
    4.2 局限性: 但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素
    4.3 memory cache 注定只能是个“短期存储”。当数据量过大，即使网页不关闭，缓存依然会失效。
    4.4 memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 <img>，两个 href 相同的 <link>)都实际只会被请求最多一次，避免浪费。

五、disk cache（HTTP缓存）【核心】
  1 硬盘缓存又叫HTTP缓存，它也是浏览器缓存中最重要的内容。
  2 DNS缓存它主要是做一个ip地址查找并且是自主完成的，memory cache 也是不受控制，算是一个黑盒。
  3 可以受我们控制的硬盘缓存的重要性就不言而喻了，大多优化手段也是针对硬盘缓存。
  4 HTTP缓存分为强制缓存和协商缓存

六、强制缓存 (也叫强缓存)
  1 对于强缓存，控制它的字段分别是：Expires和Cache-Control，其中Cache-Control优先级比Expires高。
  2 当客户端发出一个请求到服务器，服务器希望你把资源缓存起来，于是在响应头中加入了这些内容
    ```
      Cache-Control: max-age=3600 我希望你把这个资源缓存起来，缓存时间是3600秒（1小时）
      Expires: Thu, 10 Nov 2020 08:45:11 GMT 到达指定时间过期
      Date: Thu, 30 Apr 2020 12:39:56 GMT
      Etag:W/"121-171ca289ebf"，(后面协商缓存内容)这个资源的编号是W/"121-171ca289ebf"
      Last-Modified:Thu, 30 Apr 2020 08:16:31 GMT，(后面协商缓存内容)这个资源的上一次修改时间

    ```
  3 Cache-Control和 Expires分别是HTTP/1.1 和 HTTP/1.0的内容，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段我们都会设置。
  4 浏览器收到这个响应之后就会做下面的事情
    4.1 浏览器把这次请求得到的响应体缓存到本地文件中
    4.2 浏览器标记这次请求的请求方法和请求路径
    4.3 浏览器标记这次缓存的时间是3600秒
    4.4 浏览器记录服务器的响应时间是格林威治时间2020-04-30 12:39:56
    4.5 这一次的记录非常重要，它为以后浏览器要不要去请求服务器提供了依据。
    4.6 之后当客户端收准备再次请求同样的地址时，它突然想起了一件事：我需要的东西在不在缓存里呢？
    4.7 判断缓存是否有效就是通过把max-age + Date，得到一个过期时间，看看这个过期时间是否大于当前时间，如果是，则表示缓存还没有过期，仍然有效，如果不是，则表示缓存失效。

七、协商缓存 
  1 一旦发现缓存无效，它并不会简单的把缓存删除，而是抱着一丝希望，想问问服务器，我这个缓存还能继续使用吗？
    1.1 于是，浏览器向服务器发出了一个带缓存的请求
    1.2 所谓带缓存的请求，无非就是加入了以下的请求头：
    ```
      If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT  
        亲，你曾经告诉我，这个资源的上一次修改时间是格林威治时间2020-04-30 08:16:31，请问这个资源在这个时间之后有发生变动吗？
      If-None-Match: W/"121-171ca289ebf"  
        亲，你曾经告诉我，这个资源的编号是W/"121-171ca289ebf，请问这个资源的编号发生变动了吗？

    ```
    1.3 之所以要发两个信息，是为了兼容不同的服务器，因为有些服务器只认If-Modified-Since，有些服务器只认If-None-Match，有些服务器两个都认,但是一般来说 If-None-Match 的优先级高于 If-Modified-Since
    1.4 此时可能会产生两个结果
      1.4.1 **缓存失效：**那么非常简单，服务器再次给予一个正常的响应（响应码200 带响应体），同时可以附带上新的缓存指令，浏览器缓存新的内容
      1.4.2 **缓存有效：**服务器返回304重定向，并且响应头带上新的缓存指令，浏览器作出相应缓存动作。

八、补充（关键字段值）
  1 Cache-Control还可以设置下面一个或多个值：
    1.1 public：
      指示服务器资源是公开的。比如有一个页面资源，所有人看到的都是一样的。这个值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的原则，http协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不用，完全看它自己。
    1.2 private：
      指示服务器资源是私有的。比如有一个页面资源，每个用户看到的都不一样。这个值对于浏览器而言没有什么意义，但可能在某些场景可能有用。本着「我告知，你随意」的原则，http协议中很多时候都是客户端或服务器告诉另一端详细的信息，至于另一端用不用，完全看它自己。
    1.3 no-cache：
      告知客户端，你可以缓存这个资源，但是不要直接使用它。当你缓存之后，后续的每一次请求都需要附带缓存指令，让服务器告诉你这个资源有没有过期。
    1.4 no-store：
      告知客户端，不要对这个资源做任何的缓存，之后的每一次请求都按照正常的普通请求进行。若设置了这个值，浏览器将不会对该资源做出任何的缓存处理。
    1.5 max-age：不再赘述

  2 比如，Cache-Control: public, max-age=3600表示这是一个公开资源，请缓存1个小时。
  3 不仅仅是在响应头中出现，在http1.1版本中，也可以在请求头中加入Cache-Control: no-cache，它的含义是向服务器表达：不要考虑任何缓存，给我一个正常的结果。这和http1.0版本的消息头字段pragma是一样的功能。

九、expire
  1 在http1.0版本中，是通过Expire响应头来指定过期时间点的
    例如：Expire: Thu, 30 Apr 2020 23:38:38 GMT
  2 到了http1.1版本，已更改为通过Cache-Control的max-age来记录了。

十、总结
  当浏览器再次访问一个已经访问过的资源时，它会这样做：
  1 根据相关字段判断是否命中强缓存，如果命中，就直接使用缓存了。
  2 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。
  3 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。
  4 否则，返回最新的资源。